UNIVERSITY OF HELSINKI
JAVA PROGRAMMING II NOTES

### PART 8
HASH MAP
A data structure that stores a list of key-value pairs. (Compare: dictionaries in Python.)
* It exists in Java as HashMap<>(): import with java.util.HashMap
* You can set the data type of keys and values seperately:
HashMap<String, Integer> hash = new HashMap<>();
* Only one key/value pair at a time: a reassignment wipes the old value

ADD: hash.put("five", 3);
GET: hash.get("five"); retrieves the VALUE of "five" which is 3

WHEN TO USE:
* it's best to use hash maps when you know exactly what you're looking for: if you have to search based on a partial key, then it'll probably take longer and up that Big O rating since it's got to iterate
* lists are still good to sort and keep order of items

REFERENCE VARIABLES:
Anything put into a hashmap is automatically converted into a reference variable. Remember that this REFERENCES a spot in memory, it's not the actual piece of memory. Primitive is the actual spot.
int = Integer (reference)
* You CAN convert between types but it can get a little risky.
* Make sure to use getOrDefault to handle potential null cases.
	
SIMILARITY OF OBJECTS
-The 'equals' method compares the references of two objects and returns true if it's the same. Only that - even if the objects have the same values. (The String class has a version of this for identical strings.)
--As a result, we often need to build our own equals methods in objects if we want to compare them.
	=> You can compare this == object, or see if object instanceof [Object]
--Classes like ArrayList and HashMap have their own versions of these methods. Stuff added to them must be reference type as a result.

* In comparison, the 'hashCode' method in HashMap compares the hash value of two objects to see if they're the same. (Remember that hash functions are used to assign objects to the hash table, and this allows quick lookup and comparison by running values through that hash function.) Strings and Integers have hashCodes, but other objects don't.
=> To get around this, you can setup a hashCode() method in an object to grab the exact hash location of an object in a hash table and thus make approximate comparisons.

SO: to use a class as a HashMap's key, define for it:
1. the equals method, so that all equal or approximately equal objects cause the comparison to return true and all false for all the rest
2. the hashCode method, so that as few objects as possible end up with the same hash value

GROUPING DATA USING HASHMAPS
You can attach ANY variable to a key or a value, even other lists! (Once more we inevitably approach the hash table.) You still have to declare a new ArrayList<>() when adding this way.

HashMap<String, ArrayList<String>> bookFavs = new HashMap<>();
bookFavs.put("Clarence", new ArrayList<>());
bookFavs.add("Clarence","Atlas Shrugged");
bookFavs.add("Clarence","The Jungle");

### PART 9
=CLASS INHERITANCE
In object oriented programming, solutions rise from the interactions between objects that are created from classes.
=> Every object in Java is derived from the Object class, and in turn, have various subclasses. Take ArrayList:
java.lang.Object
	java.util.AbstractCollection<E>
		java.util.AbstractList<E>
			java.util.ArrayList<E>
			
This is *inheritance*, when subclasses inherit properties and behaviors from superclasses (such as equals and HashCode, that's why we had to override with our own).
=> When a subclass inherits from a superclass, this is called "extending".

Inheritance isn't ideal in every situation, but if a class has major overlap with another, along with its own properties, it might be ideal to extend it. The classic example:
public class Animal {
	public Animal(int legs) {
		//constructor
	}
	//common animal things
}

public class Dog extends Animal {
	private boolean fur;

	public Dog (int legs, boolean fur) {
		super(legs);
		this.fur = fur;
	}

	public void bark() {
		//print bark
	}
}

Dog can do all the things and has all the properties an Animal does, but it has its own unique properties and methods as well on top of that.
=This is also when access modifiers come into play. Public means anyone can see it, and private means no one can see it (not without a getter or setter). By using 'protected', you can expose these only to subclasses that extend the main class, but it's otherwise private.

The *SUPER* constructor calls on the constructor of the superclass (in this case, Animal). As a result it brings over the Animal's starting properties. You can also prefix superclass methods with super to call them. [IE: super.getName()]

=> Let's make a brief note about POLYMORPHISM:
For extended classes, executed methods is chosen based on the actual type of the object. This is because objects are *polymorphic* - they can be used by a variety of variable types.
-So basically: if you have a Student object that extends Person, and call toString on Student, it first looks in Student, and if that doesn't exist, it looks up at the next superclass in a hierarchy.

? WHEN TO USE INHERITANCE?
* It's best to use inheritance when the subclass needs to use all of the inherited functionality of the super class. AKA, a SPECIAL case of the super class.
* It's best to keep the inheritance hierarchy shallow, like two or three levels.
* If an object owns or is composed of other objects, don't use inheritance.
* Keep the Single Responsbility Principle in mind - a class should really have only one reason to change. Multiple responsibilities are best split into multiple classes. Otherwise, you might have to change way more stuff when making edits.

=INTERFACES

=OBJECT POLYMORPHISM

### PART 10

### PART 11

### PART 12

### PART 13

### PART 14

